<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Free Whiteboard</title>
  <!-- Materialize CSS for styling -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" rel="stylesheet">
  <!-- Material Icons -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #f5f5f5;
      font-family: sans-serif;
    }
    /* Toolbar positioned at top left */
    #toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 300;
    }
    /* Whiteboard container */
    #whiteboard {
      position: relative;
      width: 1250px;  /* 50px left offset + 1200px grid */
      height: 850px;  /* 800px grid + 50px bottom offset */
      margin: 50px auto;
      border: 1px solid #ccc;
      background: #fff;
      overflow: hidden;
    }
    /* Grid area with default grid lines */
    #grid {
      position: absolute;
      z-index: 1;
      left: 50px;  /* Reserve 50px on the left for the y-axis */
      top: 0;
      width: 1200px;
      height: 800px;
      background-image:
        linear-gradient(to right, #e0e0e0 1px, transparent 1px),
        linear-gradient(to bottom, #e0e0e0 1px, transparent 1px);
      background-size: 20px 20px;
    }
    /* Pill container (holds pills for used Post-its) */
    #pill-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 200;
    }
    /* Dock container fixed at the right side */
    #dock {
      position: absolute;
      top: 0;
      right: 0;
      width: 150px;
      height: 100%;
      background: #f0f0f0;
      box-shadow: -2px 0 5px rgba(0,0,0,0.2);
      z-index: 300;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 20px;
    }
    /* Each dock slot holds exactly one item */
    .dock-slot {
      width: 100%;
      height: 110px; /* For Post-its or stickers */
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 10px;
      border: 1px dashed #ccc;
      position: relative;
    }
    /* Dock Post-its are positioned statically within their slot */
    .dock-postit {
      position: static;
      width: 90%;
      min-height: 90px;
      cursor: move;
    }
    /* Used Post-its (on the canvas) are absolutely positioned */
    .post-it {
      position: absolute;
      padding: 10px;
      min-width: 100px;
      min-height: 100px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
      cursor: move;
      user-select: none;
      overflow: auto;
    }
    .post-it .content {
      outline: none;
      cursor: text;
    }
    /* Pill styling (displays relative X/Y for Post-its) */
    .pill {
      position: absolute;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      padding: 2px 5px;
      border-radius: 10px;
      font-size: 10px;
      pointer-events: none;
      white-space: nowrap;
      z-index: 1000;
    }
    /* Delete icon styling */
    .delete-icon {
      position: absolute;
      top: 0;
      left: 0;
      background: rgb(211, 210, 210);
      color: white;
      width: 15px;
      height: 15px;
      line-height: 15px;
      text-align: center;
      cursor: pointer;
      z-index: 10000;
      font-weight: bold;
    }
    /* Axis styling */
    .axis {
      position: absolute;
      background: #000;
      z-index: 1; /* Axes behind Post-its (which start at z=2). */
    }
    #x-axis {
      height: 2px;
      width: 100%;
      bottom: 0;
      left: 0;
    }
    #y-axis {
      width: 2px;
      height: 100%;
      top: 0;
      left: 0;
    }
    /* Hide the old Add Post-it button */
    #addPostitBtn {
      display: none;
    }
    /* ---------------------------
       STICKER-SPECIFIC STYLING
       --------------------------- */
    /* Sticker while in the dock */
    .dock-sticker {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      font-size: 16px;
      position: static;
      cursor: move;
    }
    /* Sticker once placed on the board */
    .sticker {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      font-size: 16px;
      cursor: move;
      user-select: none;
      /* Large z-index so itâ€™s always above Post-its */
      z-index: 999999;
    }

    .numbered-sticker {
      background-color: #ff2400; /* scarlet red */
      color: white;
    }

    .green-sticker {
        background-color: #00ff18;
        color: white;
    }

    .yellow-sticker {
        background-color: #ffeb05;
        color: black;
    }

    .orange-sticker {
        background-color: #ff8001;
        color: black;
    }

    .red-sticker {
        background-color: #ff2400;
        color: white;
    }
  </style>
</head>
<body>
  <!-- Toolbar -->
  <div id="toolbar" class="center-align">
    <a class="waves-effect waves-light btn" id="saveBtn">
      <i class="material-icons left">save</i>Save as PNG
    </a>
    <a class="waves-effect waves-light btn" id="uploadBackgroundBtn">
      <i class="material-icons left">image</i>Upload Background
    </a>
    <input type="file" id="uploadBackground" accept="image/*" style="display: none;">
  </div>

  <!-- Whiteboard container -->
  <div id="whiteboard">
    <!-- Grid area with axes -->
    <div id="grid">
      <div id="x-axis" class="axis"></div>
      <div id="y-axis" class="axis"></div>
    </div>
    <!-- Pill container -->
    <div id="pill-container"></div>
    <!-- Dock container with fixed slots -->
    <div id="dock">
      <!-- Four post-it slots -->
      <div class="dock-slot" data-color="yellow"></div>
      <div class="dock-slot" data-color="pink"></div>
      <div class="dock-slot" data-color="blue"></div>
      <div class="dock-slot" data-color="green"></div>
      
      <!-- Numbered sticker slot -->
      <div class="dock-slot" id="numbered-sticker-slot"></div>

      <!-- Additional colored sticker slots -->
      <div class="dock-slot" id="green-sticker-slot"></div>
      <div class="dock-slot" id="yellow-sticker-slot"></div>
      <div class="dock-slot" id="orange-sticker-slot"></div>
      <div class="dock-slot" id="red-sticker-slot"></div>

    </div>
  </div>

  <!-- Scripts -->
  <!-- Materialize JS and html2canvas -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script>
    /**********************
     * GLOBAL DEFINITIONS *
     **********************/
    const whiteboard = document.getElementById('whiteboard');
    const grid = document.getElementById('grid');
    const pillContainer = document.getElementById('pill-container');
    const saveBtn = document.getElementById('saveBtn');
    const uploadBackgroundBtn = document.getElementById('uploadBackgroundBtn');
    const uploadBackgroundInput = document.getElementById('uploadBackground');
    const dock = document.getElementById('dock');
    const stickerSlot = document.getElementById('sticker-slot'); // Existing sticker slot

    // New sticker slots
    const numberedStickerSlot = document.getElementById('numbered-sticker-slot');
    const greenStickerSlot = document.getElementById('green-sticker-slot');
    const yellowStickerSlot = document.getElementById('yellow-sticker-slot');
    const orangeStickerSlot = document.getElementById('orange-sticker-slot');
    const redStickerSlot = document.getElementById('red-sticker-slot');

    // Grid parameters and axis rectangles
    const gridLeft = 50, gridTop = 0, gridWidth = 1200, gridHeight = 800;
    const yAxisRect = { left: gridLeft, top: gridTop, right: gridLeft + 2, bottom: gridTop + gridHeight };
    const xAxisRect = { left: gridLeft, top: gridTop + gridHeight - 2, right: gridLeft + gridWidth, bottom: gridTop + gridHeight };

    // Global z-index counters
    let postItZ = 2;      // Post-its go upward from 2
    let stickerZ = 100001; // Stickers start at a high z-index
    let stickerCount = 1;  // Sticker numbering for the numbered stickers
    let basicStickerCount = 1; // Counter for the basic color stickers

    // The current drag state (used by the drag manager)
    let currentDrag = null;

    /********************
     * HELPER FUNCTIONS *
     ********************/
    // Clamp a value between min and max.
    const clamp = (val, min, max) => Math.max(min, Math.min(val, max));

    // Return clientX/clientY from mouse or touch event.
    function getClientCoords(e) {
      if (e.touches && e.touches.length > 0) {
        return { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY };
      }
      return { clientX: e.clientX, clientY: e.clientY };
    }

    // Check if two rectangles intersect.
    function isIntersecting(rect1, rect2) {
      return !(rect1.right < rect2.left ||
               rect1.left > rect2.right ||
               rect1.bottom < rect2.top ||
               rect1.top > rect2.bottom);
    }

    // Get the base color for a post-it based on its data attribute.
    function getBasePostItColor(elm) {
      switch(elm.dataset.color) {
        case "pink":  return "#ffc0cb";
        case "blue":  return "#add8e6";
        case "green": return "#90ee90";
        default:      return "#fffb8f"; // yellow by default
      }
    }

    // Update the pill element (which shows the relative position)
    function updatePill(elm, newX, newY) {
      let relativeX = Math.round(((newX - gridLeft) / gridWidth) * 100);
      let relativeY = Math.round((1 - ((newY - gridTop) / gridHeight)) * 100);
      if (elm.pill) {
        elm.pill.innerText = `${relativeX}%, ${relativeY}%`;
        elm.pill.style.left = newX + "px";
        elm.pill.style.top = (newY + elm.offsetHeight + 5) + "px";
      }
    }

    // Add a delete icon to a post-it element.
    function addDeleteIcon(elm) {
      const del = document.createElement('div');
      del.className = 'delete-icon';
      del.innerText = "Ã—";
      del.addEventListener('click', function(e) {
        if (elm.pill) elm.pill.remove();
        elm.remove();
        e.stopPropagation();
      });
      elm.appendChild(del);
    }

    /*********************
     * DRAG MANAGER      *
     *********************/
    // Global mouse and touch move/end handlers use the currentDrag object.
    document.addEventListener('mousemove', (e) => {
      if (currentDrag && currentDrag.onDragMove) {
        currentDrag.onDragMove(e);
        e.preventDefault();
      }
    });
    document.addEventListener('mouseup', () => {
      if (currentDrag && currentDrag.onDragEnd) currentDrag.onDragEnd();
      currentDrag = null;
    });
    document.addEventListener('touchmove', (e) => {
      if (currentDrag && currentDrag.onDragMove) {
        currentDrag.onDragMove(e);
        e.preventDefault();
      }
    }, { passive: false });
    document.addEventListener('touchend', () => {
      if (currentDrag && currentDrag.onDragEnd) currentDrag.onDragEnd();
      currentDrag = null;
    });

    /*************************************
     * POST-IT CREATION AND DRAGGING     *
     *************************************/
    // Create a new dock post-it for a given color in a given slot.
    function createDockPostit(color, slot) {
      const postit = document.createElement('div');
      postit.className = 'post-it dock-postit';
      postit.dataset.color = color;
      // Set background color based on color.
      postit.style.backgroundColor = getBasePostItColor(postit);

      const content = document.createElement('div');
      content.className = 'content';
      content.contentEditable = true;
      content.innerText = "New Post-it";
      // Prevent the content area from interfering with dragging.
      content.addEventListener('mousedown', (e) => e.stopPropagation());
      content.addEventListener('touchstart', (e) => e.stopPropagation());

      postit.appendChild(content);
      // Clear the slot and append the new post-it.
      slot.innerHTML = "";
      slot.appendChild(postit);
      // Make the post-it draggable.
      makeDraggablePostit(postit);
    }

    // When a post-it is dragged from a dock slot, reparent it to the whiteboard.
    function reparentFromDock(elm) {
      const slot = elm.parentElement;
      if (slot.classList.contains('dock-slot')) {
        const rect = elm.getBoundingClientRect();
        const wbRect = whiteboard.getBoundingClientRect();
        const newLeft = rect.left - wbRect.left;
        const newTop = rect.top - wbRect.top;
        whiteboard.appendChild(elm);
        elm.style.left = newLeft + "px";
        elm.style.top = newTop + "px";
        elm.style.zIndex = postItZ++;
        elm.classList.remove("dock-postit");
        addDeleteIcon(elm);

        // Replace the dock post-it.
        createDockPostit(elm.dataset.color, slot);

        // Create and attach a pill for the used post-it.
        const pill = document.createElement('div');
        pill.className = 'pill';
        pill.innerText = "0%, 0%";
        pillContainer.appendChild(pill);
        elm.pill = pill;
        updatePill(elm, newLeft, newTop);
      }
    }

    // Handle dragging for post-its.
    function handlePostItDrag(e, elm, startOffsetX, startOffsetY) {
      const { clientX, clientY } = getClientCoords(e);
      const boardRect = whiteboard.getBoundingClientRect();
      let newX = clamp(clientX - boardRect.left - startOffsetX, 0, boardRect.width - elm.offsetWidth);
      let newY = clamp(clientY - boardRect.top - startOffsetY, 0, boardRect.height - elm.offsetHeight);
      elm.style.left = newX + 'px';
      elm.style.top = newY + 'px';
      updatePill(elm, newX, newY);

      // Determine the rectangle of the post-it.
      const noteRect = {
        left: newX,
        top: newY,
        right: newX + elm.offsetWidth,
        bottom: newY + elm.offsetHeight
      };

      // Change background color when intersecting axes.
      if (isIntersecting(noteRect, yAxisRect)) {
        elm.style.backgroundColor = '#e8f6fa';
      } else if (isIntersecting(noteRect, xAxisRect)) {
        elm.style.backgroundColor = '#fcf9dc';
      } else {
        elm.style.backgroundColor = getBasePostItColor(elm);
      }

      // Toggle pill and delete icon visibility based on axis intersection.
      const hide = isIntersecting(noteRect, yAxisRect) || isIntersecting(noteRect, xAxisRect);
      if (elm.pill) elm.pill.style.display = hide ? "none" : "block";
      const delIcon = elm.querySelector('.delete-icon');
      if (delIcon) delIcon.style.display = hide ? "none" : "block";
    }

    // Make a post-it element draggable.
    function makeDraggablePostit(elm) {
      elm.addEventListener('mousedown', (e) => {
        // If in a dock, reparent it.
        if (elm.parentElement.classList.contains('dock-slot')) {
          reparentFromDock(elm);
        }
        // Bring the element to the front.
        elm.style.zIndex = postItZ++;
        const { clientX, clientY } = getClientCoords(e);
        const rect = elm.getBoundingClientRect();
        const offsetX = clientX - rect.left;
        const offsetY = clientY - rect.top;
        currentDrag = {
          element: elm,
          startOffsetX: offsetX,
          startOffsetY: offsetY,
          onDragMove: (ev) => handlePostItDrag(ev, elm, offsetX, offsetY),
          onDragEnd: () => {} // (No special cleanup needed.)
        };
        e.preventDefault();
      });

      elm.addEventListener('touchstart', (e) => {
        if (elm.parentElement.classList.contains('dock-slot')) {
          reparentFromDock(elm);
        }
        elm.style.zIndex = postItZ++;
        const { clientX, clientY } = getClientCoords(e);
        const rect = elm.getBoundingClientRect();
        const offsetX = clientX - rect.left;
        const offsetY = clientY - rect.top;
        currentDrag = {
          element: elm,
          startOffsetX: offsetX,
          startOffsetY: offsetY,
          onDragMove: (ev) => handlePostItDrag(ev, elm, offsetX, offsetY),
          onDragEnd: () => {}
        };
        e.preventDefault();
      }, { passive: false });
    }

     /*************************************
     * BASIC STICKER CREATION AND DRAGGING (Non-numbered) *
     *************************************/

    // Create a new dock sticker with the given color.
    function createDockBasicSticker(colorClass, slot) {
      const sticker = document.createElement('div');
      sticker.className = `dock-sticker ${colorClass}`;
      slot.innerHTML = "";
      slot.appendChild(sticker);
      makeDraggableBasicSticker(sticker, colorClass); // Pass colorClass for replacement
    }

    // Reparent a basic sticker from the dock to the whiteboard.
    function reparentBasicStickerFromDock(elm, colorClass) {
      const slot = elm.parentElement;
      if (slot.classList.contains('dock-slot')) {
        const rect = elm.getBoundingClientRect();
        const wbRect = whiteboard.getBoundingClientRect();
        const newLeft = rect.left - wbRect.left;
        const newTop = rect.top - wbRect.top;
        whiteboard.appendChild(elm);
        elm.style.left = newLeft + "px";
        elm.style.top = newTop + "px";
        elm.classList.remove("dock-sticker");
        elm.classList.add("sticker");
        elm.style.zIndex = stickerZ++;

        // Preserve the color class
        elm.className = `sticker ${colorClass}`;  //Add the colorClass for the dragged element

        // Replace the dock sticker with a new one of the same color.
        createDockBasicSticker(colorClass, slot);
      }
    }

    // Handle basic sticker dragging.
    function handleBasicStickerDrag(e, elm, startOffsetX, startOffsetY) {
      const { clientX, clientY } = getClientCoords(e);
      const boardRect = whiteboard.getBoundingClientRect();
      let newX = clamp(clientX - boardRect.left - startOffsetX, 0, boardRect.width - elm.offsetWidth);
      let newY = clamp(clientY - boardRect.top - startOffsetY, 0, boardRect.height - elm.offsetHeight);
      elm.style.left = newX + 'px';
      elm.style.top = newY + 'px';
    }

    // Make a basic sticker element draggable.
    function makeDraggableBasicSticker(elm, colorClass) {
      elm.addEventListener('mousedown', (e) => {
        if (elm.classList.contains('dock-sticker')) {
          reparentBasicStickerFromDock(elm, colorClass);  // Pass colorClass
        }
        elm.style.zIndex = stickerZ++;
        const { clientX, clientY } = getClientCoords(e);
        const rect = elm.getBoundingClientRect();
        const offsetX = clientX - rect.left;
        const offsetY = clientY - rect.top;
        currentDrag = {
          element: elm,
          startOffsetX: offsetX,
          startOffsetY: offsetY,
          onDragMove: (ev) => handleBasicStickerDrag(ev, elm, offsetX, offsetY),
          onDragEnd: () => {}
        };
        e.preventDefault();
      });

      elm.addEventListener('touchstart', (e) => {
        if (elm.classList.contains('dock-sticker')) {
          reparentBasicStickerFromDock(elm, colorClass); // Pass colorClass
        }
        elm.style.zIndex = stickerZ++;
        const { clientX, clientY } = getClientCoords(e);
        const rect = elm.getBoundingClientRect();
        const offsetX = clientX - rect.left;
        const offsetY = clientY - rect.top;
        currentDrag = {
          element: elm,
          startOffsetX: offsetX,
          startOffsetY: offsetY,
          onDragMove: (ev) => handleBasicStickerDrag(ev, elm, offsetX, offsetY),
          onDragEnd: () => {}
        };
        e.preventDefault();
      }, { passive: false });
    }


    /*************************************
     * STICKER CREATION AND DRAGGING     *
     *************************************/
    // Create a new dock sticker with the given number.
    function createDockSticker(slot) {
      const sticker = document.createElement('div');
      sticker.className = 'dock-sticker numbered-sticker';
      sticker.textContent = stickerCount++;
      slot.innerHTML = "";
      slot.appendChild(sticker);
      makeDraggableSticker(sticker);
    }

    // Reparent a sticker from the dock to the whiteboard.
    function reparentStickerFromDock(elm) {
      const slot = elm.parentElement;
      if (slot.classList.contains('dock-slot')) {
        const rect = elm.getBoundingClientRect();
        const wbRect = whiteboard.getBoundingClientRect();
        const newLeft = rect.left - wbRect.left;
        const newTop = rect.top - wbRect.top;
        whiteboard.appendChild(elm);
        elm.style.left = newLeft + "px";
        elm.style.top = newTop + "px";
        elm.classList.remove("dock-sticker");
        elm.classList.add("sticker");
        elm.classList.add("numbered-sticker"); // Add class on whiteboard
        elm.style.zIndex = stickerZ++;
        // Immediately replace the dock sticker.
        createDockSticker(slot); // Pass slot
      }
    }

    // Handle sticker dragging.
    function handleStickerDrag(e, elm, startOffsetX, startOffsetY) {
      const { clientX, clientY } = getClientCoords(e);
      const boardRect = whiteboard.getBoundingClientRect();
      let newX = clamp(clientX - boardRect.left - startOffsetX, 0, boardRect.width - elm.offsetWidth);
      let newY = clamp(clientY - boardRect.top - startOffsetY, 0, boardRect.height - elm.offsetHeight);
      elm.style.left = newX + 'px';
      elm.style.top = newY + 'px';
    }

    // Make a sticker element draggable.
    function makeDraggableSticker(elm) {
      elm.addEventListener('mousedown', (e) => {
        if (elm.classList.contains('dock-sticker')) {
          reparentStickerFromDock(elm);
        }
        elm.style.zIndex = stickerZ++;
        const { clientX, clientY } = getClientCoords(e);
        const rect = elm.getBoundingClientRect();
        const offsetX = clientX - rect.left;
        const offsetY = clientY - rect.top;
        currentDrag = {
          element: elm,
          startOffsetX: offsetX,
          startOffsetY: offsetY,
          onDragMove: (ev) => handleStickerDrag(ev, elm, offsetX, offsetY),
          onDragEnd: () => {}
        };
        e.preventDefault();
      });

      elm.addEventListener('touchstart', (e) => {
        if (elm.classList.contains('dock-sticker')) {
          reparentStickerFromDock(elm);
        }
        elm.style.zIndex = stickerZ++;
        const { clientX, clientY } = getClientCoords(e);
        const rect = elm.getBoundingClientRect();
        const offsetX = clientX - rect.left;
        const offsetY = clientY - rect.top;
        currentDrag = {
          element: elm,
          startOffsetX: offsetX,
          startOffsetY: offsetY,
          onDragMove: (ev) => handleStickerDrag(ev, elm, offsetX, offsetY),
          onDragEnd: () => {}
        };
        e.preventDefault();
      }, { passive: false });
    }

    /*************************************
     * BACKGROUND UPLOAD & PNG SAVING    *
     *************************************/
    uploadBackgroundBtn.addEventListener('click', () => {
      uploadBackgroundInput.click();
    });
    uploadBackgroundInput.addEventListener('change', function() {
      if (this.files && this.files[0]) {
        const reader = new FileReader();
        reader.onload = function(e) {
          whiteboard.style.backgroundImage = `url(${e.target.result})`;
          whiteboard.style.backgroundSize = "cover";
          whiteboard.style.backgroundPosition = "center";
          // Optionally remove grid lines:
          grid.style.backgroundImage = "none";
        }
        reader.readAsDataURL(this.files[0]);
      }
    });

    saveBtn.addEventListener('click', () => {
      html2canvas(whiteboard, { backgroundColor: null }).then((canvas) => {
        const link = document.createElement('a');
        link.download = 'whiteboard.png';
        link.href = canvas.toDataURL("image/png");
        link.click();
      });
    });

    /*************************************
     * INITIALIZATION                    *
     *************************************/
    function initializeDock() {
      const colors = ["yellow", "pink", "blue", "green"];
      const slots = document.querySelectorAll('.dock-slot[data-color]');
      slots.forEach((slot, index) => {
        createDockPostit(colors[index], slot);
      });
    }

    function initializeStickerSlots() {
        // Initialize the original numbered sticker
        createDockSticker(numberedStickerSlot);

        // Initialize the basic color stickers
        createDockBasicSticker("green-sticker", greenStickerSlot);
        createDockBasicSticker("yellow-sticker", yellowStickerSlot);
        createDockBasicSticker("orange-sticker", orangeStickerSlot);
        createDockBasicSticker("red-sticker", redStickerSlot);
    }

    // Run initialization on load.
    initializeDock();
    initializeStickerSlots();
  </script>
</body>
</html>